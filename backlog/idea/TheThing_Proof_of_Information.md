# TheThing - Proof of Information Architecture

## Overview

TheThing is a hybrid data-trust architecture designed to verify the authenticity of behavioral and sensory data generated by users.  
It combines **local processing**, **federated validation**, and **blockchain-based proofs** to create a scalable, privacy-preserving layer of digital trust.

The guiding principle is:  
> "Data should stay local, trust should be global."

---

## Core Concepts

### 1. Proof of Information (PoI)
PoI replaces "Proof of Work" or "Proof of Stake" with **Proof of Authentic Human Information**.  
Every device produces a verifiable digital trace of real sensory and behavioral activity - not fabricated data.

### 2. Light Ledger
Each device maintains a **local, lightweight ledger** of session hashes.  
Every few minutes, these hashes are merged into a **Merkle Root** and sent to a validator node.

Only the Merkle root (not the raw data) is written to blockchain.

### 3. Federated Proof
Instead of sending raw data to the cloud, devices send **model updates or statistics** (gradients, entropy, trust score).  
The central AI aggregates these updates to learn global patterns without violating privacy.

---

## Data Flow Architecture

```mermaid
flowchart TD
    A[Sensor Layer (on device)] --> B[Local Data Buffer / SQLite]
    B --> C[Entropy & Trust Scoring]
    C --> D[Light Ledger (hash chain)]
    D --> E[Periodic Merkle Root Generation]
    E --> F[Federated Proof Uploader]
    F --> G[Cloud Validator / Aggregator]
    G --> H[Blockchain Layer (Solana / Polygon)]
    H --> I[Reward Distribution + PoI Token Mint]
```

---

## Data Layers

| Layer | Location | Purpose | Technology |
|-------|-----------|----------|-------------|
| **1. Sensor Layer** | Device | Raw behavioral and environmental data | Android sensors / Kotlin / NDK |
| **2. Local Ledger** | Device | Hash chain of session data | SQLite + SHA-256 |
| **3. Federated Proof** | Device  Cloud | Aggregate updates / model deltas | TensorFlow Federated / PySyft |
| **4. Validator Node** | Cloud | Verifies proof integrity | Node.js / Rust |
| **5. Blockchain Layer** | Public Network | Immutable proof + rewards | Solana / Polygon / Avalanche |

---

## Sensory Fingerprinting

### Goal
To create a **unique, non-intrusive behavioral fingerprint** proving that data originates from a real, consistent human device - not a bot or emulator.

### Sensory Sources (Phase 1)

| Sensor | Type | Features Used | Purpose |
|--------|------|---------------|----------|
| **Accelerometer / Gyroscope** | motion | micro-movement frequency, jitter, reaction time | Detects real human motion and rhythm |
| **Touchscreen** | interaction | pressure, swipe velocity, multi-touch timing | Builds behavioral identity |
| **Light Sensor / Camera** | environment | brightness variance, frame entropy | Confirms presence and movement |
| **Microphone (no audio stored)** | sound level | amplitude variance, frequency rhythm | Detects ambient authenticity |
| **Battery / Power Events** | system | charge patterns, heat, voltage drift | Helps prevent emulation |
| **System Clock & Local Time Drift** | system | micro-drift pattern | Unique per hardware |
| **Network Latency** | context | average ping jitter | Hardware-level variance signature |

### Fingerprint Structure (JSON Example)

```json
{
  "session_id": "XTB-COS-2025-001",
  "motion_vector": [0.94, 1.02, 0.11],
  "touch_signature": "ab14dfe3",
  "env_entropy": 0.78,
  "sound_variance": 0.56,
  "battery_curve": "3.95V4.12V/15min",
  "trust_score": 91,
  "timestamp": 1730119200
}
```

Each fingerprint  hashed  added to Light Ledger  included in next Merkle root.

---

## Verification Pipeline

### Step 1 - Contextual Verification
Correlates sensor inputs (e.g. movement + sound + touch) to detect consistency.  
If correlation < threshold  mark as low-trust data.

### Step 2 - Statistical Verification
Compares current fingerprint to historical behavioral patterns.  
Outliers are flagged but not discarded - system learns adaptability.

### Step 3 - Cryptographic Verification
Each fingerprint batch is hashed (SHA-256) and signed with local private key (stored in Android Keystore / Secure Enclave).

### Step 4 - Merkle Proof
Local hashes combined  Merkle Root  transmitted to validator node  written to blockchain.

### Step 5 - Reward Issuance
Blockchain contract verifies proof + entropy threshold  mints PoI tokens.

---

## Security & Privacy Principles

- **On-device processing first**: no raw data leaves the device.
- **Hashed + signed transmission**: only proofs and stats leave the device.
- **Zero-knowledge capable**: architecture compatible with zk-proof verification in future versions.
- **Device-bound identity**: fingerprint tied to cryptographic keypair (not user account).
- **User transparency**: clear logs of what data was sensed and when.

---

## Technologies

| Layer | Technology |
|--------|-------------|
| Device | Kotlin / Jetpack / TensorFlow Lite / Rust NDK |
| Local Ledger | SQLite / SHA-256 / Merkle Tree |
| Federated Proof | PySyft / TensorFlow Federated |
| Cloud Validator | Node.js / Rust / PostgreSQL |
| Blockchain | Solana / Polygon / Light-Ledger sidechain |

---

## Scalability Strategy

1. **Batch Proofs:** combine multiple device proofs into one Merkle root every 15 minutes.  
2. **Federated Learning:** aggregate local trust models rather than collecting data.  
3. **Token Rewards:** proportional to entropy  trust  consistency.  
4. **Local pruning:** delete raw data after hash commitment (privacy).  

---

## Example Blockchain Record

```json
{
  "hash_root": "0xA9C34F2...",
  "device_id": "C0S-00931",
  "entropy": 0.84,
  "trust": 92,
  "timestamp": 1730119200,
  "signature": "0x93abff12...",
  "reward": 0.0025
}
```

---

## Benefits

-  High data authenticity (hard to fake multi-sensor input)
-  Privacy by design (no raw data transfer)
-  Energy-efficient (light hashing + batching)
-  Scalable (millions of devices with batch proofs)
-  Modular - each layer replaceable (AI / Blockchain / Ledger)

---

## Limitations

-  Higher architectural complexity (3-layer coordination)
-  Requires secure key management per device
-  Offline devices delay proof submission
-  Hash reversibility risk (requires salted hash)
-  Needs periodic synchronization and pruning

---

## Future Enhancements

1. **ZK-Proof Integration:** replace hashes with zero-knowledge attestations.  
2. **Trusted Execution (TEE):** run fingerprinting inside hardware enclaves.  
3. **Entropy-Based Tokenomics:** dynamic reward curves per data variety.  
4. **Community Validation:** peer scoring of data quality.  
5. **AI-Driven Fraud Detection:** pattern learning on federated updates.

---

## TODO / NEXT STEPS

- [ ] Implement sensor collection module (accelerometer, touch, light, sound).  
- [ ] Design SQLite + hash-chain structure for Light Ledger.  
- [ ] Build Merkle root generator in Rust (low CPU).  
- [ ] Integrate PoI validator microservice (Node.js).  
- [ ] Deploy test smart contract on Solana devnet.  
- [ ] Create visualization dashboard for entropy / trust evolution.  
- [ ] Write PoI SDK documentation for Android / Kotlin devs.

---

**Document:** `TheThing_Proof_of_Information.md`  
**Version:** 1.0  
**Author:** Adrian Soja & Elysia (2025)  
**License:** CC BY-NC 4.0
